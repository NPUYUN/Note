# 最短路（Shortest Path）
## 定义
在加权图中，从源点到目标点或所有点之间寻找总权重最小的路径。常见场景：单源单目标（s→t）、单源到所有点、所有点对最短路。

## 模型三要素
- 图元素：顶点集合V、边集合E、边权重w(e)。
- 目标函数：最小化路径总权重。
- 约束条件：路径连通与流守恒；可选约束如避障、容量、访问次数等。

## 数学形式（路径流模型）
设二元变量x_e表示是否选取边e（无额外约束时可放宽为[0,1]的连续变量）：
$$
\begin{aligned}
\min\; & \sum_{e\in E} w(e)\, x_e \\
\text{s.t.}\; & \sum_{e\in \delta^+(v)} x_e - \sum_{e\in \delta^-(v)} x_e = \begin{cases}
1, & v = s \\
-1, & v = t \\
0, & \text{else}
\end{cases} \\
& x_e \in \{0,1\}\; (\text{或}\; x_e \in [0,1])
\end{aligned}
$$
当无负权环时，该问题也可通过势函数/动态规划高效求解。

## 建模要点
- 非负权图优先使用 Dijkstra；存在负权但无负环使用 Bellman-Ford。
- 全点对最短路使用 Floyd–Warshall 或在稀疏图上多次 Dijkstra。
- 启发式搜索（A*）在有可行启发函数时更快（如欧氏/曼哈顿距离）。
- 路径带复杂额外约束时可转为整数规划或约束规划（CP-SAT）。

## 求解示例
### NetworkX（Dijkstra/Bellman-Ford/A*）
```python
import networkx as nx

G = nx.DiGraph()
G.add_weighted_edges_from([
    ("s", "a", 1.0),
    ("s", "b", 4.0),
    ("a", "b", 2.0),
    ("a", "t", 5.0),
    ("b", "t", 1.0),
])

p1 = nx.dijkstra_path(G, "s", "t", weight="weight")
d1 = nx.dijkstra_path_length(G, "s", "t", weight="weight")

p2 = nx.bellman_ford_path(G, "s", "t", weight="weight")
d2 = nx.bellman_ford_path_length(G, "s", "t", weight="weight")

def h(n):
    return 0.0

p3 = nx.astar_path(G, "s", "t", heuristic=h, weight="weight")
d3 = nx.astar_path_length(G, "s", "t", heuristic=h, weight="weight")

print(p1, d1)
print(p2, d2)
print(p3, d3)
```

### 全点对（Floyd–Warshall）
```python
import networkx as nx

G = nx.DiGraph()
G.add_weighted_edges_from([
    (0, 1, 3), (0, 2, 8), (0, 4, -4),
    (1, 3, 1), (1, 4, 7),
    (2, 1, 4),
    (3, 0, 2), (3, 2, -5),
    (4, 3, 6)
])

dist = dict(nx.floyd_warshall(G, weight="weight"))
print(dist[0][3])
```

### 数学规划（PuLP，带二元变量）
```python
import pulp as lp

V = ["s", "a", "b", "t"]
E = [("s","a",1.0),("s","b",4.0),("a","b",2.0),("a","t",5.0),("b","t",1.0)]

m = lp.LpProblem("SP", lp.LpMinimize)

x = { (u,v): lp.LpVariable(f"x_{u}_{v}", lowBound=0, upBound=1, cat=lp.LpBinary) for (u,v,_) in E }

m += lp.lpSum(w * x[(u,v)] for (u,v,w) in E)

for v in V:
    inflow = lp.lpSum(x[(u,u2)] for (u,u2,_) in E if u2 == v)
    outflow = lp.lpSum(x[(v,u2)] for (v2,u2,_) in E if v2 == v)
    if v == "s":
        m += outflow - inflow == 1
    elif v == "t":
        m += outflow - inflow == -1
    else:
        m += outflow - inflow == 0

status = m.solve()

print(lp.LpStatus[status])
print(lp.value(m.objective))
```

## 进阶话题
- 有向/无向、稠密/稀疏图的数据结构选择与复杂度分析。
- 负权与负环检测，Johnson 算法在稀疏图上的应用。
- 约束最短路（时间窗、必经点、禁行边）与CP/ILP混合建模。
