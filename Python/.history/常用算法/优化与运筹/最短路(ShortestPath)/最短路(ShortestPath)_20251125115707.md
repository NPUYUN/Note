# 最短路
## 定义
在加权图中，从源点到目标点或所有点之间寻找总权重最小的路径。常见场景：单源单目标（s→t）、单源到所有点、所有点对最短路。

## 常用算法
### 单源最短路
- Dijkstra算法：适用于非负权重图，时间复杂度O((V+E)logV)。
- Bellman-Ford算法：适用于负权重图，时间复杂度O(VE)。
### 多源最短路
- Floyd-Warshall算法：适用于所有点对最短路，时间复杂度O(V^3)。
### 启发式算法
- A*算法：结合了Dijkstra和启发式函数，适用于有启发式信息的图，时间复杂度O((V+E)logV)。

## 使用Python解决最短路问题
### NetworkX
NetworkX库提供了丰富的最短路算法实现，包括Dijkstra、Bellman-Ford、Floyd-Warshall等。

#### 基础语法如下
``` python
import networkx as nx

# 1. 创建一个空的无向图（对于有向图，使用 nx.DiGraph()）
G = nx.Graph()

# 2. 添加带权重的边（添加边时会自动添加节点）
G.add_edge('A', 'B', weight=4)
G.add_edge('B', 'D', weight=2)
G.add_edge('A', 'C', weight=3)
G.add_edge('C', 'D', weight=5)
G.add_edge('A', 'D', weight=6)

# 3. 计算从节点A到节点D的最短路径和距离
try:
    # 获取最短路径经过的节点列表
    shortest_path = nx.shortest_path(G, source='A', target='D', weight='weight')
    # 获取最短路径的长度（总权重）
    shortest_path_length = nx.shortest_path_length(G, source='A', target='D', weight='weight')
    
    print(f"最短路径: {shortest_path}")  # 输出： ['A', 'B', 'D']
    print(f"最短距离: {shortest_path_length}")  # 输出： 6
except nx.NetworkXNoPath:
    print("两点之间不存在路径。")
```
代码解释：
- 创建一个空的无向图`G`。
- 添加带权重的边，例如`G.add_edge('A', 'B', weight=4)`表示节点A到节点B的权重为4。
- 计算从节点A到节点D的最短路径和距离，使用`nx.shortest_path(G, source='A', target='D', weight='weight')`和`nx.shortest_path_length(G, source='A', target='D', weight='weight')`。
- 打印最短路径和距离。如果不存在路径，则捕获`nx.NetworkXNoPath`异常并打印提示信息。

NetworkX库默认通常是Dijkstra算法，也可以指定其他算法，如Bellman-Ford或Floyd-Warshall。
``` python
# 使用Bellman-Ford算法计算最短路径
shortest_path = nx.bellman_ford_path(G, source='A', target='D', weight='weight')
```
``` python
# 使用Floyd-Warshall算法计算所有点对最短路径
shortest_path = nx.floyd_warshall_path(G, source='A', target='D', weight='weight')
```
``` python
# 使用A*算法计算最短路径
shortest_path = nx.astar_path(G, source='A', target='D', weight='weight', heuristic=func)
```
注意：
- A*算法需要提供一个启发式函数`func`，用于估计从当前节点到目标节点的距离，否则退化成Dijkstra算法。
- 启发式函数必须是一个非负函数，且不能高估实际距离。