# 网络流（Network Flow）
## 定义
在带容量与成本的有向图上，对流量在各边上的分配进行优化。典型问题：最大流（Max-Flow）、最小费用最大流（Min-Cost Max-Flow）、有供需的最小费用流（Min-Cost Flow）。

## 模型三要素
- 图元素：顶点集合V、边集合E、容量`u(e)`与费用`c(e)`。
- 目标函数：最大化从源到汇的总流量，或在满足供需与容量下最小化总费用。
- 约束条件：容量上界、非负流量、节点流守恒（除源/汇或供需节点）。

## 数学形式
最大流：
$$
\begin{aligned}
\max\; & \sum_{(s,j)\in E} f_{sj} \\
\text{s.t.}\; & 0 \le f_{ij} \le u_{ij},\ \forall (i,j)\in E \\
& \sum_{(i,j)\in E} f_{ij} - \sum_{(k,i)\in E} f_{ki} = \begin{cases}
1,& i=s \\
-1,& i=t \\
0,& \text{else}
\end{cases}
\end{aligned}
$$

最小费用流（有供需）：
$$
\begin{aligned}
\min\; & \sum_{(i,j)\in E} c_{ij}\, f_{ij} \\
\text{s.t.}\; & 0 \le f_{ij} \le u_{ij},\ \forall (i,j)\in E \\
& \sum_{(i,j)\in E} f_{ij} - \sum_{(k,i)\in E} f_{ki} = b_i,\ \forall i\in V
\end{aligned}
$$
其中`b_i`为节点供需（源为正、汇为负、其他为0）。

## 建模要点
- 最大流可用 Edmonds–Karp、Dinic 等算法；稀疏图通常更快。
- 最小费用流常用逐次最短路、势函数（Johnson 重标）以应对负边费用。
- 大规模问题可使用专用求解器（OR‑Tools `SimpleMinCostFlow`、`SimpleMaxFlow`）。
- 复杂业务约束（强制路由、限行、分层容量）可转 ILP/CP 混合建模。

## 求解示例
### NetworkX（最大流 / 最小费用最大流）
```python
import networkx as nx

G = nx.DiGraph()
G.add_edge("s", "a", capacity=3, weight=2)
G.add_edge("s", "b", capacity=2, weight=4)
G.add_edge("a", "t", capacity=2, weight=1)
G.add_edge("b", "t", capacity=3, weight=1)
G.add_edge("a", "b", capacity=2, weight=0)

# 最大流（Edmonds-Karp）
flow_dict, flow_val = nx.maximum_flow(G, "s", "t", capacity="capacity")
print(flow_val)
print(flow_dict)

# 最小费用的最大流
flow_mcmf = nx.max_flow_min_cost(G, "s", "t", capacity="capacity", weight="weight")
cost = nx.cost_of_flow(G, flow_mcmf, weight="weight")
print(cost)
```

### OR-Tools（有供需的最小费用流）
```python
from ortools.graph import pywrapgraph

start_nodes = [0, 0, 1, 2]
end_nodes   = [1, 2, 3, 3]
capacities  = [3, 2, 2, 3]
unit_costs  = [2, 4, 1, 1]
supplies    = [5, 0, 0, -5]  # 0源供给为5，3汇需求为5

min_cost_flow = pywrapgraph.SimpleMinCostFlow()
for i in range(len(start_nodes)):
    min_cost_flow.AddArcWithCapacityAndUnitCost(start_nodes[i], end_nodes[i], capacities[i], unit_costs[i])
for i, s in enumerate(supplies):
    min_cost_flow.SetNodeSupply(i, s)

status = min_cost_flow.Solve()
print(status == min_cost_flow.OPTIMAL)
print(min_cost_flow.OptimalCost())
```

### PuLP（ILP：最小费用流）
```python
import pulp as lp

V = [0, 1, 2, 3]
E = [(0,1,3,2), (0,2,2,4), (1,3,2,1), (2,3,3,1)]  # (u,v,cap,cost)
b = {0: 5, 3: -5, 1: 0, 2: 0}

m = lp.LpProblem("MinCostFlow", lp.LpMinimize)
f = {(u,v): lp.LpVariable(f"f_{u}_{v}", lowBound=0, upBound=cap) for (u,v,cap,_) in E}

m += lp.lpSum(cost * f[(u,v)] for (u,v,_,cost) in E)

for i in V:
    outflow = lp.lpSum(f[(i,j)] for (i2,j,_,_) in E if i2 == i)
    inflow  = lp.lpSum(f[(j,i)] for (j,i2,_,_) in E if i2 == i)
    m += outflow - inflow == b[i]

status = m.solve()
print(lp.LpStatus[status])
print(lp.value(m.objective))
```

## 进阶话题
- 多商品流（Multi-Commodity Flow）：在共享容量上同时路由多类流，典型为多源多汇路由与带颜色/类别的流。
- 分段线性成本与阶梯容量：用额外变量/约束建模非线性费用与分级容量。
- 对偶视角与最短路：费用可用势函数重标；增广路径通常以最短路搜索实现。

