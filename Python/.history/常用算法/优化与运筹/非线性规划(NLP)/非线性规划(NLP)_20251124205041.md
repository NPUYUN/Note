# 非线性规划（NLP）
## 定义
在约束或目标函数中包含非线性项的优化问题。按可行域与目标的几何性质可分为凸与非凸问题；凸问题具有全局最优性保证，非凸问题通常需启发式或多起点策略。

## 模型三要素
- 决策变量：连续变量为主，亦可含整数（转为MINLP）。
- 目标函数：可微/不可微的非线性（平方、范数、对数、指数等）。
- 约束条件：等式/不等式的非线性函数与符号约束。

## 数学形式示例
一般形式：
$$
\begin{aligned}
\min\; & f(x) \\
\text{s.t.}\; & g_i(x) \le 0,\ i=1,\dots,m \\
& h_j(x) = 0,\ j=1,\dots,p \\
& x \in \mathbb{R}^n
\end{aligned}
$$

凸二次（QP）示例：
$$
\begin{aligned}
\min\; & \tfrac{1}{2}x^\top Q x + c^\top x \\
\text{s.t.}\; & Ax \le b
\end{aligned}
$$

非凸示例：
$$
\begin{aligned}
\min\; & (x_1-1)^4 + (x_2+2)^2 \\
\text{s.t.}\; & \sin(x_1) + x_2^2 \le 1
\end{aligned}
$$

## 建模要点
- 先判断凸性，凸问题优先用带全局保证的凸优化求解器。
- 对非凸问题使用多起点、粗到精的网格/随机搜索，或与启发式结合。
- 约束可用惩罚/罚函数近似，但需权衡数值稳定与可行性。
- 对可微问题提供梯度/雅可比/海森信息以提升收敛。

## 求解示例
### SciPy（SLSQP/Nelder-Mead 等）
```python
import numpy as np
from scipy.optimize import minimize, NonlinearConstraint

def f(x):
    return 0.5*np.dot(x, x) + np.dot(np.array([1.0, -2.0]), x)

def g(x):
    return np.sin(x[0]) + x[1]**2 - 1.0

nlc = NonlinearConstraint(g, -np.inf, 0.0)

x0 = np.array([0.5, 0.5])

res = minimize(f, x0, method="SLSQP", constraints=[nlc], bounds=[(0, None), (0, None)])

print(res.status)
print(res.x)
print(res.fun)
```

### CVXPY（凸问题）
```python
import cvxpy as cp
import numpy as np

Q = np.array([[2.0, 0.0], [0.0, 4.0]])
c = np.array([1.0, -2.0])
A = np.array([[1.0, 1.0]])
b = np.array([2.0])

x = cp.Variable(2)

obj = cp.Minimize(0.5*cp.quad_form(x, Q) + c @ x)
cons = [A @ x <= b,
        x >= 0]

prob = cp.Problem(obj, cons)
prob.solve()

print(x.value)
print(obj.value)
```

### Pyomo（一般NLP）
```python
import pyomo.environ as pyo

m = pyo.ConcreteModel()
m.x1 = pyo.Var(bounds=(0, None))
m.x2 = pyo.Var(bounds=(0, None))

def obj(m):
    return 0.5*(m.x1**2 + m.x2**2) + 1.0*m.x1 - 2.0*m.x2

m.obj = pyo.Objective(rule=obj, sense=pyo.minimize)
m.c1 = pyo.Constraint(expr=pyo.sin(m.x1) + m.x2**2 <= 1.0)

solver = pyo.SolverFactory("ipopt")
res = solver.solve(m)

print(pyo.value(m.x1), pyo.value(m.x2))
print(pyo.value(m.obj))
```
