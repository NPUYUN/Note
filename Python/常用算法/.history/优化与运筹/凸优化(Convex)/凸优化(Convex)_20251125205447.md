# 凸优化

## 基本概念
**凸优化**是数学优化领域的一个重要分支，研究在凸集上对凸函数进行最小化(或最大化)的问题。

**形式化定义**：一个优化问题被称为凸优化，当且仅当：
1. **目标函数**是凸函数
2. **约束条件**构成的可行集是凸集

### 1. 凸函数
函数$f: \mathbb{R}^n \rightarrow \mathbb{R}$是凸函数，当且仅当对任意$x, y \in \mathbb{R}^n$和$\theta \in [0,1]$，有：
$$f(\theta x + (1-\theta)y) \leq \theta f(x) + (1-\theta)f(y)$$
直观理解：函数图像上任意两点间的连线都位于函数图像上方(或重合)，形状如"碗形"。

### 2. 凸集
集合$C \subseteq \mathbb{R}^n$是凸集，当且仅当对任意$x, y \in C$和$\theta \in [0,1]$，有：
$$\theta x + (1-\theta)y \in C$$
直观理解：集合内任意两点的连线全部包含在该集合内。

### 凸优化的关键特性

#### 1. **全局最优保证**
**最重要的性质**：凸优化问题的**局部最优解必定是全局最优解**。这是凸优化区别于非凸优化的决定性特征，使得求解变得高效可靠。

#### 2. **求解效率**
凸优化问题可通过多种成熟算法高效求解，理论上可在**多项式时间**内解决，适用于大规模问题。

### 常见的凸优化问题类型
许多重要的优化问题都属于凸优化的范畴，或者可以通过变换转化为凸优化问题：
#### 线性规划：
目标函数和约束条件都是线性的。这是最经典、最基础的凸优化问题。
线性规划问题的形式化定义如下：
$$
\begin{aligned}
\min_{x \in \mathbb{R}^n} & \quad c^T x \\
\text{s.t.} & \quad A x \leq b \\
& \quad x \geq 0
\end{aligned}
$$
其中，$c, b$是列向量，$A$是矩阵。

#### 二次规划：
目标函数是二次的（但要求其二次型矩阵是半正定的，这样才能保证函数的凸性），约束条件是线性的。
二次规划问题的形式化定义如下：
$$
\begin{aligned}
\min_{x \in \mathbb{R}^n} & \quad \frac{1}{2} x^T P x + q^T x \\
\text{s.t.} & \quad G x \leq h \\
& \quad A x = b
\end{aligned}
$$
其中，$P$是二次项系数矩阵(半正定矩阵)，$q, h, b$是列向量，$G, A$是矩阵。

#### 半定规划：
是线性规划的一种推广，涉及矩阵变量和半正定约束，在系统控制和组合优化等领域有重要应用。
半定规划问题的形式化定义如下：
$$
\begin{aligned}
\min_{X \in \mathbb{R}^{n \times n}} & \quad \frac{1}{2} X^T P X + q^T X \\
\text{s.t.} & \quad G X \leq h \\
& \quad A X = b \\
& \quad X \succeq 0
\end{aligned}
$$
其中，$P$是二次项系数矩阵(半正定矩阵)，$q, h, b$是列向量，$G, A$是矩阵, $X$是矩阵变量(半正定矩阵)。

#### 锥规划：
包括二阶锥规划等，是更一般的框架。
锥规划问题的形式化定义如下：
$$
\begin{aligned}
\min_{x \in \mathbb{R}^n} & \quad c^T x \\
\text{s.t.} & \quad Ax \in K \\
& \quad x \geq 0
\end{aligned}
$$
其中，$c, b$是列向量，$A$是矩阵，$K$是锥。



## Python解决凸优化问题
CVXPY是一个用于凸优化的Python库，它提供了简洁的接口来定义和解决凸优化问题。
CVXPY默认使用标准的凸优化模型，即**最小化目标函数**，**所有约束条件都是小于等于符号**

### 二次规划
#### 基本流程如下
``` python
import cvxpy as cp
import numpy as np

# 定义优化变量，这里是2维向量
x = cp.Variable(2)

# 定义二次规划的参数
# 矩阵Q（要求是对称正定或半正定）
Q = np.array([[2.0, 0.5],
              [0.5, 1.0]])
# 向量c
c = np.array([1.0, 2.0])

# 构建目标函数：Minimize (1/2)x^T Q x + c^T x
objective = cp.Minimize((1/2) * cp.quad_form(x, Q) + c.T @ x)

# 构建约束条件：A x <= b 和 x >= 0
A = np.array([[1.0, 1.0],
              [-1.0, 0.0],
              [0.0, -1.0]])
b = np.array([1.0, 0.0, 0.0])
constraints = [A @ x <= b, x >= 0]

# 定义问题并求解
problem = cp.Problem(objective, constraints)
problem.solve()  # 默认会调用适合的求解器（如ECOS）

# 输出结果
print("状态:", problem.status)
print("最优值: {:.4f}".format(problem.value))
print("最优解 x =", x.value)
```
代码解释：
- 定义优化变量：$x \in \mathbb{R}^2$，表示我们要优化的2维向量。
- 定义二次规划的参数：$Q$是二次项系数矩阵，$c$是线性项系数向量。
- 构建目标函数：$f(x) = (1/2) x^T Q x + c^T x$，我们要最小化这个函数。
- 构建约束条件：$A x \leq b$和$x \geq 0$，表示可行域。本例中为$x_1, x_2 \geq 0$ ，$A x = b$为$x_1 + x_2 <= 1$。
- 定义问题并求解：使用CVXPY的`Problem`类定义问题，调用`solve`方法求解。
- 输出结果：包括问题状态、最优值和最优解。
###### 注意：
- `@` 是Python中的矩阵乘法运算符，用于计算向量的点积或矩阵的乘积。
- `cp.quad_form(x, Q)`表示$x^T Q x$，即二次项的计算。

### 半定规划
#### 基本流程如下
``` python
import cvxpy as cp
import numpy as np

# 定义问题维度
n = 3
p = 3  # 约束条件数量

# 生成随机问题数据（在实际应用中，这些矩阵由你的具体问题决定）
np.random.seed(1)
C = np.random.randn(n, n)
C = (C + C.T) / 2  # 确保C为对称矩阵
A_list = []
b_list = []
for i in range(p):
    A_i = np.random.randn(n, n)
    A_list.append((A_i + A_i.T) / 2)  # 确保每个A_i为对称矩阵
    b_list.append(np.random.randn())

# 1. 定义优化变量：一个n*n的对称矩阵X
X = cp.Variable((n, n), symmetric=True)

# 2. 构建约束条件：X必须是半正定矩阵，并添加线性等式约束
constraints = [X >> 0]  # ">>" 表示半正定约束
constraints += [cp.trace(A_list[i] @ X) == b_list[i] for i in range(p)]

# 3. 定义目标函数：最小化矩阵C和X的内积（即Trace(C^T X)）
objective = cp.Minimize(cp.trace(C.T @ X))

# 4. 定义问题并求解
prob = cp.Problem(objective, constraints)
prob.solve()

# 5. 输出结果
print("问题求解状态:", prob.status)
print("最优目标函数值:", prob.value)
print("解矩阵 X:")
print(X.value)
```
代码解释：
- 定义问题维度：$n=3$，$p=3$，表示矩阵$X$是3*3的对称矩阵，有3个线性等式约束。
- 生成随机问题数据：$C$是一个3*3的对称矩阵，$A_i$是3*3的对称矩阵，$b_i$是一个标量。
- 定义优化变量：$X \in \mathbb{R}^{3 \times 3}$，表示我们要优化的3*3对称矩阵。
- 构建约束条件：$X$必须是半正定矩阵，即$X \succeq 0$。同时，添加3个线性等式约束：$X^T A_i X = b_i$。
- 定义目标函数：$f(X) = Trace(C^T X)$，我们要最小化这个函数。
- 定义问题并求解：使用CVXPY的`Problem`类定义问题，调用`solve`方法求解。
- 输出结果：包括问题状态、最优值和最优解。



线性规划见**优化与运筹**的线性规划部分。
