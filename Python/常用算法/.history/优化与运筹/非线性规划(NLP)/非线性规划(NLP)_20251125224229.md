# 非线性规划(NLP)全解

## 基本概念

**非线性规划**是最优化理论的重要分支，指**目标函数或约束条件中至少有一个是非线性函数的数学规划问题**。

- **"非线性"**：变量间关系不是简单的一次方(线性)，而是包含平方、开方、乘积、指数、对数等复杂运算
- **"规划"**：在给定约束下，寻找决策变量的最优值，使目标函数达到最大或最小

**数学模型**：
$$
\begin{aligned}
\min/\max\quad & f(x) \\
\text{s.t.}\quad & g_i(x) \le 0,\quad i = 1,2,\dots,m, \\
& h_j(x) = 0,\quad j = 1,2,\dots,p, \\
& x \in \mathbb{R}^n
\end{aligned}
$$
- $f(x)$：目标函数(非线性)
- $g_i(x)$：不等式约束(可非线性)
- $h_j(x)$：等式约束(可非线性)
- $x$：决策变量向量

### 与线性规划的区别

| 特性 | 线性规划(LP) | 非线性规划(NLP) |
|------|--------------|----------------|
| 函数形式 | 目标和约束全为一次函数 | 至少一个非线性项(平方、乘积等) |
| 可行域形状 | 凸多面体(直线、平面构成) | 任意复杂形状(曲线、曲面) |
| 最优解位置 | 顶点上 | 可行域内任意点(含内部) |
| 求解难度 | 有通用算法(单纯形法) | 无通用解法,各算法适用范围有限 |
| 解的数量 | 有限个极值点 | 可能有无穷多极值点 |

**本质差异**：线性规划描述"平直"关系,非线性规划处理"弯曲"关系,更贴近现实世界的复杂问题。

### 主要类型

#### 无约束优化
- **定义**：目标函数和约束条件均无约束
- **应用**：简单问题、理论研究等

#### 凸规划
- **定义**：目标函数为凸函数,可行域为凸集
- **特性**：任何局部最优解必为全局最优解；最优解集为凸集
- **应用**：经济模型、资源分配等全局优化问题

#### 二次规划(QP)
- **定义**：目标函数为二次函数,约束为线性
- **形式**：min f(x)=x^T Qx + c^T x
  s.t. Ax ≤ b, x ≥ 0
- **特性**：最简单的非线性规划,有较成熟求解方法
- **应用**：投资组合优化(风险计算涉及方差)、工程设计

#### 几何规划
- **定义**：目标函数和约束由单项式组成
- **应用**：工程设计、电路优化等

## Python求解非线性规划
### 无约束优化
Scipy提供了`minimize_scalar`函数来求解单变量无约束优化问题。
###### 基本语法
`scipy.optimize.minimize(fun, x0, args=(), method=None, jac=None, hess=None, hessp=None, bounds=None, constraints=(), tol=None, callback=None, options=None)`
其中：
- `fun`：目标函数
- `x0`：初始解(标量或向量)
- `args`：目标函数的参数(元组形式)
- `method`：优化方法(默认`None`，使用最优法)
- `jac`：目标函数的梯度(可选)
- `hess`：目标函数的海森矩阵(可选)
- `hessp`：目标函数的海森矩阵-向量积(可选)
- `bounds`：变量的边界(可选)
- `constraints`：约束条件(可选)
- `tol`：迭代停止精度(默认1.48e-08)
- `callback`：每次迭代调用的函数(可选)
- `options`：优化方法的参数(可选)

返回值：
- `x`：最优解
- `fun`：最优值
- `nit`：迭代次数
- `nfev`：函数调用次数
- `warnflag`：警告标志(1表示收敛失败)

#### 单变量
``` python
from scipy.optimize import minimize_scalar

# 定义目标函数
def objective(x):
    return x**2 + 3*x + 2

# 调用 minimize_scalar 函数
result = minimize_scalar(objective, brack=(-10, 10))

# 打印结果
print("最优解:", result.x)
print("最优值:", result.fun)
print("迭代次数:", result.nit)
print("函数调用次数:", result.nfev)
print("警告标志:", result.warnflag)
```
注意：不指定method时，默认使用最优法。
method可以指定的方法有：
- `'brent'`：Brent方法(默认),
- `'golden'`：黄金分割法
- `'bounded'`：有界域搜索法

也可以直接使用`brent(func, args=(), brack=None, tol=1.48e-08, full_output=0, maxiter=500)`指定使用Brent方法。
其中
  `func`为目标函数，
  `args`为目标函数的参数(元组形式)，
  `brack`为初始搜索区间(元组形式,如`(a, b)`)，
  `tol`为迭代停止精度(默认1.48e-08)，
  `full_output`为是否返回详细信息(0或1)，
  `maxiter`为最大迭代次数(默认500)

#### 多变量
``` python
import numpy as np
from scipy.optimize import minimize

# 1. 定义目标函数（Rosenbrock函数）
def rosenbrock(x):
    return sum(100.0 * (x[1:] - x[:-1]**2)**2 + (1 - x[:-1])**2)

# 2. 定义目标函数的梯度（一阶导数）(可选)
def rosenbrock_grad(x):
    x = np.asarray(x)
    grad = np.zeros_like(x)
    grad[0] = -400 * x[0] * (x[1] - x[0]**2) - 2 * (1 - x[0])
    grad[-1] = 200 * (x[-1] - x[-2]**2)
    for i in range(1, len(x)-1):
        grad[i] = 200 * (x[i] - x[i-1]**2) - 400 * x[i] * (x[i+1] - x[i]**2) - 2 * (1 - x[i])
    return grad

# 3. 设置初始点
x0 = np.array([1.3, 0.7, 1.8, 1.9, 1.2])

# 4. 调用 minimize 函数
result = minimize(rosenbrock, x0, method='BFGS', jac=rosenbrock_grad, bounds=[(-5, 5)]*len(x0))

# 5. 打印结果
print("最优解:", result.x)
print("最优值:", result.fun)
print("迭代次数:", result.nit)
print("函数调用次数:", result.nfev)
print("警告标志:", result.warnflag)
```
注意：不指定method时，默认使用BFGS方法。
method可以指定的方法有：
- `'BFGS'`：BFGS方法(默认)
- `'L-BFGS-B'`：L-BFGS-B方法(带边界约束)
- `'Nelder-Mead '`：Nelder-Mead 方法(无需求导)，收敛速度较慢

也可以直接使用`fmin(func, x0, args=(), xtol=0.0001, ftol=0.0001, maxiter=None, maxfun=None, full_output=0, disp=1, retall=0, callback=None, initial_simplex=None)`指定使用Nelder-Mead方法。
其中
  `func`为目标函数，
  `x0`为初始解(向量形式)，
  `args`为目标函数的参数(元组形式)，
  `xtol`为迭代停止精度(默认0.0001)，
  `ftol`为迭代停止精度(默认0.0001)，
  `maxiter`为最大迭代次数(默认None)，
  `maxfun`为最大函数调用次数(默认None)，
  `full_output`为是否返回详细信息(0或1)，
  `disp`为是否显示迭代信息(0或1)，
  `retall`为是否返回所有迭代解(0或1)，
  `callback`为每次迭代调用的函数(可选)，
  `initial_simplex`为初始 simplex 矩阵(可选)。
  


### 二次规划(QP)
当其二次型矩阵是半正定时(即为凸函数时)，变为凸规划，
这里讨论二次规划一般的情况，即不从凸函数的角度出发，而是从一般的非线性规划的角度出发。

### 几何规划


凸规划见**优化与运筹**的**凸优化**部分。