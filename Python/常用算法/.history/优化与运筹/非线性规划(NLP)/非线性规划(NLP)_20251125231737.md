# 非线性规划(NLP)全解

## 基本概念

**非线性规划**是最优化理论的重要分支，指**目标函数或约束条件中至少有一个是非线性函数的数学规划问题**。

- **"非线性"**：变量间关系不是简单的一次方(线性)，而是包含平方、开方、乘积、指数、对数等复杂运算
- **"规划"**：在给定约束下，寻找决策变量的最优值，使目标函数达到最大或最小

**数学模型**：
$$
\begin{aligned}
\min/\max\quad & f(x) \\
\text{s.t.}\quad & g_i(x) \le 0,\quad i = 1,2,\dots,m, \\
& h_j(x) = 0,\quad j = 1,2,\dots,p, \\
& x \in \mathbb{R}^n
\end{aligned}
$$
- $f(x)$：目标函数(非线性)
- $g_i(x)$：不等式约束(可非线性)
- $h_j(x)$：等式约束(可非线性)
- $x$：决策变量向量

### 与线性规划的区别

| 特性 | 线性规划(LP) | 非线性规划(NLP) |
|------|--------------|----------------|
| 函数形式 | 目标和约束全为一次函数 | 至少一个非线性项(平方、乘积等) |
| 可行域形状 | 凸多面体(直线、平面构成) | 任意复杂形状(曲线、曲面) |
| 最优解位置 | 顶点上 | 可行域内任意点(含内部) |
| 求解难度 | 有通用算法(单纯形法) | 无通用解法,各算法适用范围有限 |
| 解的数量 | 有限个极值点 | 可能有无穷多极值点 |

**本质差异**：线性规划描述"平直"关系,非线性规划处理"弯曲"关系,更贴近现实世界的复杂问题。

### 主要类型

#### 无约束优化
- **定义**：目标函数和约束条件均无约束
- **应用**：简单问题、理论研究等

#### 凸规划
- **定义**：目标函数为凸函数,可行域为凸集
- **特性**：任何局部最优解必为全局最优解；最优解集为凸集
- **应用**：经济模型、资源分配等全局优化问题

#### 二次规划(QP)
- **定义**：目标函数为二次函数,约束为线性
- **形式**：min f(x)=x^T Qx + c^T x
  s.t. Ax ≤ b, x ≥ 0
- **特性**：最简单的非线性规划,有较成熟求解方法
- **应用**：投资组合优化(风险计算涉及方差)、工程设计

#### 几何规划
- **定义**：目标函数和约束由单项式组成
- **应用**：工程设计、电路优化等

## Python求解非线性规划
Scipy提供了`minimize_scalar`函数来求解单变量无约束优化问题。
##### 基本语法
``` python
scipy.optimize.minimize(fun, x0, args=(), method=None, jac=None, hess=None, hessp=None, bounds=None, constraints=(), tol=None, callback=None, options=None)
```
其中：
- `fun`：目标函数
- `x0`：初始解(标量或向量)
- `args`：目标函数的参数(元组形式)
- `method`：优化方法(默认`None`，使用最优法)
- `jac`：目标函数的梯度(可选)
- `hess`：目标函数的海森矩阵(可选)
- `hessp`：目标函数的海森矩阵-向量积(可选)
- `bounds`：变量的边界(可选)
- `constraints`：约束条件(可选)
- `tol`：迭代停止精度(默认1.48e-08)
- `callback`：每次迭代调用的函数(可选)
- `options`：优化方法的参数(可选)

返回值：
- `x`：最优解
- `fun`：最优值
- `nit`：迭代次数
- `nfev`：函数调用次数

### 无约束优化
#### 单变量
``` python
from scipy.optimize import minimize_scalar

# 定义目标函数
def objective(x):
    return x**2 + 3*x + 2

# 调用 minimize_scalar 函数
result = minimize_scalar(objective, brack=(-10, 10))

# 打印结果
print("最优解:", result.x)
print("最优值:", result.fun)
print("迭代次数:", result.nit)
print("函数调用次数:", result.nfev)
```
注意：不指定method时，默认使用最优法。
method可以指定的方法有：
- `'brent'`：Brent方法(默认),
- `'golden'`：黄金分割法
- `'bounded'`：有界域搜索法

也可以直接使用
``` python
brent(func, args=(), brack=None, tol=1.48e-08, full_output=0, maxiter=500)
```
指定使用Brent方法。
其中
  `func`为目标函数，
  `args`为目标函数的参数(元组形式)，
  `brack`为初始搜索区间(元组形式,如`(a, b)`)，
  `tol`为迭代停止精度(默认1.48e-08)，
  `full_output`为是否返回详细信息(0或1)，
  `maxiter`为最大迭代次数(默认500)

#### 多变量
``` python
import numpy as np
from scipy.optimize import minimize

# 1. 定义目标函数（Rosenbrock函数）
def rosenbrock(x):
    return sum(100.0 * (x[1:] - x[:-1]**2)**2 + (1 - x[:-1])**2)

# 2. 定义目标函数的梯度（一阶导数）(可选)
def rosenbrock_grad(x):
    x = np.asarray(x)
    grad = np.zeros_like(x)
    grad[0] = -400 * x[0] * (x[1] - x[0]**2) - 2 * (1 - x[0])
    grad[-1] = 200 * (x[-1] - x[-2]**2)
    for i in range(1, len(x)-1):
        grad[i] = 200 * (x[i] - x[i-1]**2) - 400 * x[i] * (x[i+1] - x[i]**2) - 2 * (1 - x[i])
    return grad

# 3. 设置初始点
x0 = np.array([1.3, 0.7, 1.8, 1.9, 1.2])

# 4. 调用 minimize 函数
result = minimize(rosenbrock, x0, method='L-BFGS-B', jac=rosenbrock_grad, bounds=[(-5, 5)]*len(x0))

# 5. 打印结果
print("最优解:", result.x)
print("最优值:", result.fun)
print("迭代次数:", result.nit)
print("函数调用次数:", result.nfev)
```
注意：不指定method时，默认使用BFGS方法。
method可以指定的方法有：
- `'BFGS'`：BFGS方法(默认)(无边界约束)
- `'L-BFGS-B'`：L-BFGS-B方法(带边界约束)
- `'Nelder-Mead '`：Nelder-Mead 方法(无需求导)，收敛速度较慢

也可以直接使用
``` python
fmin(func, x0, args=(), xtol=0.0001, ftol=0.0001, maxiter=None, maxfun=None, full_output=0, disp=1, retall=0, callback=None, initial_simplex=None)
```
指定使用Nelder-Mead方法。
其中
  `func`为目标函数，
  `x0`为初始解(向量形式)，
  `args`为目标函数的参数(元组形式)，
  `xtol`为迭代停止精度(默认0.0001)，
  `ftol`为迭代停止精度(默认0.0001)，
  `maxiter`为最大迭代次数(默认None)，
  `maxfun`为最大函数调用次数(默认None)，
  `full_output`为是否返回详细信息(0或1)，
  `disp`为是否显示迭代信息(0或1)，
  `retall`为是否返回所有迭代解(0或1)，
  `callback`为每次迭代调用的函数(可选)，
  `initial_simplex`为初始 simplex 矩阵(可选)。

### 二次规划(QP)
当其二次型矩阵是半正定时(即为凸函数时)，变为凸规划，
这里讨论二次规划一般的情况，即不从凸函数的角度出发，而是从一般的非线性规划的角度出发。
``` python
import numpy as np
from scipy.optimize import minimize

# 目标函数: min -x^2 + y^2 + x*y + 2*x + y (由于存在负二次项，Hessian矩阵不定，为非凸函数)
P = np.array([[-2, 0.5], [0.5, 2]])  # 二次项系数矩阵（注意非凸性）
q = np.array([2, 1])                 # 一次项系数向量

def objective(x):
    """目标函数"""
    return 0.5 * x @ P @ x + q @ x  # 标准二次型形式: 1/2 * x^T P x + q^T x

# 约束条件设置示例
def constraint1(x):
    """不等式约束示例: x + y <= 10 """
    return 10 - (x[0] + x[1])

def constraint2(x):
    """等式约束示例: x - y = 1 """
    return x[0] - x[1] - 1

# 变量边界（可选）
bounds = ((-10, 10), (-10, 10))  # x和y的取值范围

# 约束条件字典列表
constraints = [
    {'type': 'ineq', 'fun': constraint1},  # 类型 'ineq' 表示 constraint1(x) >= 0
    {'type': 'eq', 'fun': constraint2}     # 类型 'eq' 表示 constraint2(x) = 0
]

# 尝试不同的初始点以提高找到更好解的机会
initial_guesses = [np.array([0, 0]), np.array([1, 1]), np.array([-1, -1])]

best_solution = None
best_value = float('inf')

for x0 in initial_guesses:
    # 使用SLSQP算法进行求解
    result = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints)
    
    if result.success and result.fun < best_value:
        best_value = result.fun
        best_solution = result

# 输出最优结果
if best_solution is not None:
    print("求解成功!")
    print(f"最优解: x = {best_solution.x[0]:.4f}, y = {best_solution.x[1]:.4f}")
    print(f"最优目标函数值: {best_solution.fun:.4f}")
    print(f"是否收敛: {best_solution.success}")
    print(f"最终目标函数值: {best_solution.fun}")
else:
    print("所有初始点尝试均未成功找到解。")
```
注意：
1. 最终结果强烈依赖于选择的初始值。建议尝试多个不同的初始点
2. 算法通常收敛到局部最优解，而非全局最优解
3. constraints参数为约束条件列表，每个元素为一个字典，包含类型(type)和函数(fun)。
   - 类型 'ineq' 表示不等式约束(fun(x) >= 0)
   - 类型 'eq' 表示等式约束(fun(x) = 0)
4. method可以指定的方法有：
   - `'SLSQP'`：SLSQP方法(默认)
   - `'COBYLA'`：COBYLA方法(无需求导)，收敛速度较慢
   - `'trust-constr'`：信赖域约束优化方法，收敛速度较快


### 几何规划
CVXPY 是一个强大的凸优化建模库，它能够自动识别几何规划问题并将其转化为等价的凸优化问题（具体是指数锥规划），然后调用相应的求解器（如SCS、ECOS等）进行求解。
#### 基本流程如下
``` python
import cvxpy as cp

# 定义优化变量（必须为正数）
x = cp.Variable(pos=True, name="x")
y = cp.Variable(pos=True, name="y")

# 定义目标函数（必须是正项式）
objective = cp.Minimize(x**(-2) * y**(-1))

# 定义约束条件（不等式约束也必须由正项式构成）
constraints = [x + y <= 1]

# 定义问题。gp=True 是关键，它告诉CVXPY这是一个几何规划问题
problem = cp.Problem(objective, constraints)

# 求解问题
problem.solve(gp=True)

# 输出结果
print("问题状态:", problem.status)
print("最优值:", problem.value)
print("最优解:")
print(" x =", x.value)
print(" y =", y.value)
```


## 几个典型的非线性规划问题
### 单变量无约束
求函数 f(x)=x2−8sin(2x+π)的最小值

### 多变量无约束
一家彩电制造商计划推出两种新产品：一种19英寸立体声彩色电视机（建议零售价339美元）和一种21英寸立体声彩色电视机（零售价399美元）。公司的生产成本为：19英寸彩电每台195美元，21英寸彩电每台225美元，此外还有400,000美元的固定成本。
在竞争市场中，销量会影响售价。据估计，对于每种彩电，每多售出一台，其平均售价会下降0.01美元（价格弹性系数）。同时，两种彩电的销售会相互影响：每售出一台21英寸彩电，19英寸彩电的平均售价会下降0.003美元；每售出一台19英寸彩电，21英寸彩电的平均售价会下降0.004美元。
制造商需要决定每种彩电各生产多少台，才能使得总利润最大化

### 二次规划(QP)
假设我们要搭建一个马戏团帐篷，帐篷由厚重的弹性材料制成，覆盖一块方形场地，并由四角的四根较短支柱和中心的一根较高支柱支撑。我们需要找到帐篷在重力作用下自然成型的形状，这可以转化为一个优化问题：在满足支撑和边界条件的前提下，使帐篷材料的总势能最小

### 几何规划
设计一个体积固定的长方体容器，使其表面积最小

凸规划见**优化与运筹**的**凸优化**部分。